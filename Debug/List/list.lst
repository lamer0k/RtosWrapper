###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         21/Mar/2020  13:52:35
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\list.c
#    Command line =
#        -f C:\Users\Serge\AppData\Local\Temp\EWEF72.tmp
#        (C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\list.c -lC
#        C:\GitHub\KursovoyKarkas\Debug\List -lA
#        C:\GitHub\KursovoyKarkas\Debug\List -o
#        C:\GitHub\KursovoyKarkas\Debug\Obj --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I C:\GitHub\KursovoyKarkas\Rtos\
#        -I C:\GitHub\KursovoyKarkas\Rtos\wrapper\ -I
#        C:\GitHub\KursovoyKarkas\Rtos\wrapper\FreeRtos\ -I
#        C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\ -I
#        C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\include\ -I
#        C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\portable\ -I
#        C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\portable\Common\ -I
#        C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\portable\IAR\ -I
#        C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\portable\IAR\ARM_CM4F\ -I
#        C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\portable\MemMang\ -I
#        C:\GitHub\KursovoyKarkas\MyTasks\ -I C:\GitHub\KursovoyKarkas\Common\
#        -I C:\GitHub\KursovoyKarkas\CMSIS\ -I
#        C:\GitHub\KursovoyKarkas\Application\ -I
#        C:\GitHub\KursovoyKarkas\Application\Diagnostic\ -I
#        C:\GitHub\KursovoyKarkas\AHardware\ -I
#        C:\GitHub\KursovoyKarkas\AHardware\GpioPort\ -I
#        C:\GitHub\KursovoyKarkas\AHardware\IrqController\ -I
#        C:\GitHub\KursovoyKarkas\..\CortexLib\AbstractHardware\Pin\ -I
#        C:\GitHub\KursovoyKarkas\..\CortexLib\AbstractHardware\Registers\STM32F411\FieldValues\
#        -I
#        C:\GitHub\KursovoyKarkas\..\CortexLib\AbstractHardware\Registers\STM32F411\
#        -I C:\GitHub\KursovoyKarkas\..\CortexLib\AbstractHardware\Registers\
#        -I C:\GitHub\KursovoyKarkas\..\CortexLib\AbstractHardware\Port\ -I
#        C:\GitHub\KursovoyKarkas\..\CortexLib\AbstractHardware\Atomic\ -I
#        C:\GitHub\KursovoyKarkas\..\CortexLib\Common\ -I
#        C:\GitHub\KursovoyKarkas\..\CortexLib\Common\Singleton\ -Ol)
#    Locale       =  C
#    List file    =  C:\GitHub\KursovoyKarkas\Debug\List\list.lst
#    Object file  =  C:\GitHub\KursovoyKarkas\Debug\Obj\list.o
#
###############################################################################

C:\GitHub\KursovoyKarkas\Rtos\FreeRtos\list.c
      1          /*
      2              FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          
     71          #include <stdlib.h>
     72          #include "FreeRTOS.h"
     73          #include "list.h"
     74          
     75          /*-----------------------------------------------------------
     76           * PUBLIC LIST API documented in list.h
     77           *----------------------------------------------------------*/
     78          

   \                                 In section .text, align 2, keep-with-next
     79          void vListInitialise( List_t * const pxList )
     80          {
     81          	/* The list structure contains a list item which is used to mark the
     82          	end of the list.  To initialise the list the list end is inserted
     83          	as the only list entry. */
     84          	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \                     vListInitialise: (+1)
   \        0x0   0xF110 0x0108      ADDS     R1,R0,#+8
   \        0x4   0x6041             STR      R1,[R0, #+4]
     85          
     86          	/* The list end value is the highest possible value in the list to
     87          	ensure it remains at the end of the list. */
     88          	pxList->xListEnd.xItemValue = portMAX_DELAY;
   \        0x6   0xF05F 0x31FF      MOVS     R1,#-1
   \        0xA   0x6081             STR      R1,[R0, #+8]
     89          
     90          	/* The list end next and previous pointers point to itself so we know
     91          	when the list is empty. */
     92          	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \        0xC   0xF110 0x0108      ADDS     R1,R0,#+8
   \       0x10   0x60C1             STR      R1,[R0, #+12]
     93          	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \       0x12   0xF110 0x0108      ADDS     R1,R0,#+8
   \       0x16   0x6101             STR      R1,[R0, #+16]
     94          
     95          	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6001             STR      R1,[R0, #+0]
     96          
     97          	/* Write known values into the list if
     98          	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
     99          	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    100          	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
    101          }
   \       0x1C   0x4770             BX       LR               ;; return
    102          /*-----------------------------------------------------------*/
    103          

   \                                 In section .text, align 2, keep-with-next
    104          void vListInitialiseItem( ListItem_t * const pxItem )
    105          {
    106          	/* Make sure the list item is not recorded as being on a list. */
    107          	pxItem->pvContainer = NULL;
   \                     vListInitialiseItem: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6101             STR      R1,[R0, #+16]
    108          
    109          	/* Write known values into the list item if
    110          	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    111          	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    112          	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    113          }
   \        0x4   0x4770             BX       LR               ;; return
    114          /*-----------------------------------------------------------*/
    115          

   \                                 In section .text, align 2, keep-with-next
    116          void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
    117          {
    118          ListItem_t * const pxIndex = pxList->pxIndex;
   \                     vListInsertEnd: (+1)
   \        0x0   0x6842             LDR      R2,[R0, #+4]
    119          
    120          	/* Only effective when configASSERT() is also defined, these tests may catch
    121          	the list data structures being overwritten in memory.  They will not catch
    122          	data errors caused by incorrect configuration or use of FreeRTOS. */
    123          	listTEST_LIST_INTEGRITY( pxList );
    124          	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
    125          
    126          	/* Insert a new list item into pxList, but rather than sort the list,
    127          	makes the new list item the last item to be removed by a call to
    128          	listGET_OWNER_OF_NEXT_ENTRY(). */
    129          	pxNewListItem->pxNext = pxIndex;
   \        0x2   0x604A             STR      R2,[R1, #+4]
    130          	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   \        0x4   0x6893             LDR      R3,[R2, #+8]
   \        0x6   0x608B             STR      R3,[R1, #+8]
    131          
    132          	/* Only used during decision coverage testing. */
    133          	mtCOVERAGE_TEST_DELAY();
    134          
    135          	pxIndex->pxPrevious->pxNext = pxNewListItem;
   \        0x8   0x6893             LDR      R3,[R2, #+8]
   \        0xA   0x6059             STR      R1,[R3, #+4]
    136          	pxIndex->pxPrevious = pxNewListItem;
   \        0xC   0x6091             STR      R1,[R2, #+8]
    137          
    138          	/* Remember which list the item is in. */
    139          	pxNewListItem->pvContainer = ( void * ) pxList;
   \        0xE   0x6108             STR      R0,[R1, #+16]
    140          
    141          	( pxList->uxNumberOfItems )++;
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x1C49             ADDS     R1,R1,#+1
   \       0x14   0x6001             STR      R1,[R0, #+0]
    142          }
   \       0x16   0x4770             BX       LR               ;; return
    143          /*-----------------------------------------------------------*/
    144          

   \                                 In section .text, align 2, keep-with-next
    145          void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
    146          {
   \                     vListInsert: (+1)
   \        0x0   0xB410             PUSH     {R4}
    147          ListItem_t *pxIterator;
    148          const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   \        0x2   0x680B             LDR      R3,[R1, #+0]
    149          
    150          	/* Only effective when configASSERT() is also defined, these tests may catch
    151          	the list data structures being overwritten in memory.  They will not catch
    152          	data errors caused by incorrect configuration or use of FreeRTOS. */
    153          	listTEST_LIST_INTEGRITY( pxList );
    154          	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
    155          
    156          	/* Insert the new list item into the list, sorted in xItemValue order.
    157          
    158          	If the list already contains a list item with the same item value then the
    159          	new list item should be placed after it.  This ensures that TCB's which are
    160          	stored in ready lists (all of which have the same xItemValue value) get a
    161          	share of the CPU.  However, if the xItemValue is the same as the back marker
    162          	the iteration loop below will not end.  Therefore the value is checked
    163          	first, and the algorithm slightly modified if necessary. */
    164          	if( xValueOfInsertion == portMAX_DELAY )
   \        0x4   0xF113 0x0F01      CMN      R3,#+1
   \        0x8   0xD101             BNE.N    ??vListInsert_0
    165          	{
    166          		pxIterator = pxList->xListEnd.pxPrevious;
   \        0xA   0x6902             LDR      R2,[R0, #+16]
   \        0xC   0xE007             B.N      ??vListInsert_1
    167          	}
    168          	else
    169          	{
    170          		/* *** NOTE ***********************************************************
    171          		If you find your application is crashing here then likely causes are
    172          		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
    173          		more tips, and ensure configASSERT() is defined!
    174          		http://www.freertos.org/a00110.html#configASSERT
    175          
    176          			1) Stack overflow -
    177          			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
    178          			2) Incorrect interrupt priority assignment, especially on Cortex-M
    179          			   parts where numerically high priority values denote low actual
    180          			   interrupt priorities, which can seem counter intuitive.  See
    181          			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
    182          			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
    183          			   http://www.freertos.org/a00110.html
    184          			3) Calling an API function from within a critical section or when
    185          			   the scheduler is suspended, or calling an API function that does
    186          			   not end in "FromISR" from an interrupt.
    187          			4) Using a queue or semaphore before it has been initialised or
    188          			   before the scheduler has been started (are interrupts firing
    189          			   before vTaskStartScheduler() has been called?).
    190          		**********************************************************************/
    191          
    192          		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \                     ??vListInsert_0: (+1)
   \        0xE   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x12   0xE000             B.N      ??vListInsert_2
   \                     ??vListInsert_3: (+1)
   \       0x14   0x6852             LDR      R2,[R2, #+4]
   \                     ??vListInsert_2: (+1)
   \       0x16   0x6854             LDR      R4,[R2, #+4]
   \       0x18   0x6824             LDR      R4,[R4, #+0]
   \       0x1A   0x42A3             CMP      R3,R4
   \       0x1C   0xD2FA             BCS.N    ??vListInsert_3
    193          		{
    194          			/* There is nothing to do here, just iterating to the wanted
    195          			insertion position. */
    196          		}
    197          	}
    198          
    199          	pxNewListItem->pxNext = pxIterator->pxNext;
   \                     ??vListInsert_1: (+1)
   \       0x1E   0x6853             LDR      R3,[R2, #+4]
   \       0x20   0x604B             STR      R3,[R1, #+4]
    200          	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   \       0x22   0x684B             LDR      R3,[R1, #+4]
   \       0x24   0x6099             STR      R1,[R3, #+8]
    201          	pxNewListItem->pxPrevious = pxIterator;
   \       0x26   0x608A             STR      R2,[R1, #+8]
    202          	pxIterator->pxNext = pxNewListItem;
   \       0x28   0x6051             STR      R1,[R2, #+4]
    203          
    204          	/* Remember which list the item is in.  This allows fast removal of the
    205          	item later. */
    206          	pxNewListItem->pvContainer = ( void * ) pxList;
   \       0x2A   0x6108             STR      R0,[R1, #+16]
    207          
    208          	( pxList->uxNumberOfItems )++;
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x1C49             ADDS     R1,R1,#+1
   \       0x30   0x6001             STR      R1,[R0, #+0]
    209          }
   \       0x32   0xBC10             POP      {R4}
   \       0x34   0x4770             BX       LR               ;; return
    210          /*-----------------------------------------------------------*/
    211          

   \                                 In section .text, align 2, keep-with-next
    212          UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
    213          {
    214          /* The list item knows which list it is in.  Obtain the list from the list
    215          item. */
    216          List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   \                     uxListRemove: (+1)
   \        0x0   0x6901             LDR      R1,[R0, #+16]
    217          
    218          	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   \        0x2   0x6882             LDR      R2,[R0, #+8]
   \        0x4   0x6843             LDR      R3,[R0, #+4]
   \        0x6   0x609A             STR      R2,[R3, #+8]
    219          	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   \        0x8   0x6842             LDR      R2,[R0, #+4]
   \        0xA   0x6883             LDR      R3,[R0, #+8]
   \        0xC   0x605A             STR      R2,[R3, #+4]
    220          
    221          	/* Only used during decision coverage testing. */
    222          	mtCOVERAGE_TEST_DELAY();
    223          
    224          	/* Make sure the index is left pointing to a valid item. */
    225          	if( pxList->pxIndex == pxItemToRemove )
   \        0xE   0x684A             LDR      R2,[R1, #+4]
   \       0x10   0x4282             CMP      R2,R0
   \       0x12   0xD101             BNE.N    ??uxListRemove_0
    226          	{
    227          		pxList->pxIndex = pxItemToRemove->pxPrevious;
   \       0x14   0x6882             LDR      R2,[R0, #+8]
   \       0x16   0x604A             STR      R2,[R1, #+4]
    228          	}
    229          	else
    230          	{
    231          		mtCOVERAGE_TEST_MARKER();
    232          	}
    233          
    234          	pxItemToRemove->pvContainer = NULL;
   \                     ??uxListRemove_0: (+1)
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x6102             STR      R2,[R0, #+16]
    235          	( pxList->uxNumberOfItems )--;
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x1E40             SUBS     R0,R0,#+1
   \       0x20   0x6008             STR      R0,[R1, #+0]
    236          
    237          	return pxList->uxNumberOfItems;
   \       0x22   0x6808             LDR      R0,[R1, #+0]
   \       0x24   0x4770             BX       LR               ;; return
    238          }
    239          /*-----------------------------------------------------------*/
    240          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   uxListRemove
       0   vListInitialise
       0   vListInitialiseItem
       4   vListInsert
       0   vListInsertEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      38  uxListRemove
      30  vListInitialise
       6  vListInitialiseItem
      54  vListInsert
      24  vListInsertEnd

 
 152 bytes in section .text
 
 152 bytes of CODE memory

Errors: none
Warnings: none
